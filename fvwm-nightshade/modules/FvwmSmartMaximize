#!/usr/bin/perl
#-----------------------------------------------------------------------
# File:		FvwmSmartMaximize
# Version:	1.1.0
# Licence: 	GPL 2
#
# Description:	Module to move and resize a current window to the largest 
#				free area of desktop/page.
# 				implement as described in:
# 				http://www.mail-archive.com/fvwm@lists.math.uh.edu/msg16809.html
#
# Author:		Andreas Hoenen <andreas@hoenen-terstappen.de>
# Adapted by:	Thomas Funk <t.funk@web.de>
#
# Created:	06/29/2013
# Changed:	07/17/2013
#-----------------------------------------------------------------------

use warnings;
use strict;

use List::Util qw(min);

use lib `fvwm-perllib dir`;
use FVWM::Module;
#use Data::Dumper qw(Dumper);

my $module = new FVWM::Module(Name => "FvwmSmartMaximize", Mask => M_STRING);
my $pageTrackerWL = $module->track('WindowList');
my $vp_width = $pageTrackerWL->pageInfo->{vp_width};
my $vp_height = $pageTrackerWL->pageInfo->{vp_height};

$module->add_handler(M_STRING, \&smartMaximize);
$module->event_loop;

# main function smartMaximize gets called when issuing an FVWM command like:
# SendToModule smart_maximize.pl dummy
sub smartMaximize
{
    my ($module, $event) = @_;
	my $action = $event->{arg_values}[-1];

    # the window to be maximized
    my $own = $pageTrackerWL->data(${$event->args}{win_id});

	# the size of a desktop/page (90%) <- if EwmhBaseStruts has reduced
	# the real desktop/page area
	my $deskArea = $vp_width * $vp_height * 0.9;
	
    # we want the window to actually grow
    my $minArea =
        $own->{width} * $own->{height} + min($own->{width}, $own->{height});
	
	# reduce minArea to 1/8 to smart maximize maximized windows, too.
	my $reduced = 0;
	if ($minArea >= $deskArea)
	{
		$minArea = int($minArea/8);
		$reduced = 1;
	}
	
    # Find all free rectangles in the current page where the window could be
    # displayed. This works as follows:
    # The list of display rectangles starts with one preliminary display
    # rectangle: the whole page.
    # Then one after another all windows are applied to the list of the
    # preliminary display rectangles.
    # If a window overlaps with a rectangle, it splits the rectangle into at
    # most four smaller rectangles: the one above the window, the one below it,
    # the one left of it, the one right of it.
    # Any rectangle not bigger than the window to be maximized gets discarded
    # at once.
    # After all windows have been applied to the rectangle list, the display
    # rectangles are not preliminary any longer, as they won't be split into
    # smaller rectangles any longer.
    # The biggest display rectangle will be used as the new window location.
    my @rectangles = (&createRectangle($own->{page_nx} * $vp_width,
                                       ($own->{page_nx} + 1) * $vp_width,
                                       $own->{page_ny} * $vp_height,
                                       ($own->{page_ny} + 1) * $vp_height));

    # apply all windows to the display rectangle list
    foreach my $other ($pageTrackerWL->windows)
    {
		# If 90% of the current page is filled from a window this one will be
		# ignored if "IgnoreMaxWindows" is set.
		my $otherArea = 0;
		if ($action eq "IgnoreMaxWindows")
		{
			$otherArea = $other->{width} * $other->{height};
		}
        unless ($other->{win_id} == $own->{win_id}
                or $other->{desk} != $own->{desk}
                or $otherArea >= $deskArea)
        {
            @rectangles = &applyWindow($other, $minArea, @rectangles);
        }
    }

    # take the rectangle with the largest area as destination
    my $dest;
    foreach my $rect (@rectangles)
    {
        if ($dest)
        {
            # first level criterion: bigger
            if ($rect->{area} > $dest->{area}
                # second level criterion: just as big, but more left
                or ($rect->{area} == $dest->{area}
                    and ($rect->{x_min} < $dest->{x_min}
                         # third level criterion:
                         # just as big, just as left, but more up
                         or ($rect->{x_min} == $dest->{x_min}
                             and $rect->{y_min} < $dest->{y_min}))))
            {
                $dest = $rect;
            }
        }
        else
        {
            $dest = $rect;
        }
    }

    if ($dest)
    {
        # move the window to the display rectangle and let it fill
        my $x = $dest->{x_min} - $own->{page_nx} * $vp_width;
        my $y = $dest->{y_min} - $own->{page_ny} * $vp_height;
        my $newWidth = $vp_width - $x;
        my $newHeight = $vp_height - $y;
        if ($reduced)
        {
			# reduce a maximized window to 25% of its real size
			$newWidth = int($own->{width} * 0.25);
			$newHeight = int($own->{height} * 0.25);
		}
		else
		{
			# This is to eliminate flipping to other pages if Window 
			# overlap to the other page
			if ($own->{width} < $newWidth)
			{
				$newWidth = $own->{width};
			}
			if ($own->{height} < $newHeight)
			{
				$newHeight = $own->{height};
			}
		}
		$module->send("WindowId $own->{win_id} ResizeMove ${newWidth}p ${newHeight}p ${x}p ${y}p Warp");
        $module->send("WindowId $own->{win_id} Maximize screen c grow grow");
        # if window is maximized and should grow on the right side mouse cursor could flip to other page.
        $module->send("WindowId $own->{win_id} WarpToWindow 50 10");
    }
}

# Apply a window to the current display rectangle list.
# This may change the rectangle list.
sub applyWindow
{
    my ($other, $minArea, @oldRectangles, $reduce) = @_;

    my $splitter =
    {x_min => $other->{page_nx} * $vp_width + $other->{x},
     x_max => $other->{page_nx} * $vp_width + $other->{x} + $other->{width},
     y_min => $other->{page_ny} * $vp_height + $other->{y},
     y_max => $other->{page_ny} * $vp_height + $other->{y} + $other->{height}};
    my @newRectangles;

    # apply the window to all display rectangles
    foreach my $rect (@oldRectangles)
    {
        if (&doRectanglesOverlap($rect, $splitter))
        {
            # the window splits the rectangle into 0-4 new, smaller rectangles
            if ($rect->{x_min} < $splitter->{x_min})
            {
                # new rectangle left of splitter window
                my $r = &createRectangle($rect->{x_min},
                                         $splitter->{x_min} - 1,
                                         $rect->{y_min},
                                         $rect->{y_max});
                push @newRectangles, $r if $r->{area} >= $minArea;
            }
            if ($rect->{x_max} > $splitter->{x_max})
            {
                # new rectangle right of splitter window
                my $r = &createRectangle($splitter->{x_max} + 1,
                                         $rect->{x_max},
                                         $rect->{y_min},
                                         $rect->{y_max});
                push @newRectangles, $r if $r->{area} >= $minArea;
            }
            if ($rect->{y_min} < $splitter->{y_min})
            {
                # new rectangle above splitter window
                my $r = &createRectangle($rect->{x_min},
                                         $rect->{x_max},
                                         $rect->{y_min},
                                         $splitter->{y_min} - 1);
                push @newRectangles, $r if $r->{area} >= $minArea;
            }
            if ($rect->{y_max} > $splitter->{y_max})
            {
                # new rectangle below splitter window
                my $r = &createRectangle($rect->{x_min},
                                         $rect->{x_max},
                                         $splitter->{y_max} + 1,
                                         $rect->{y_max});
                push @newRectangles, $r if $r->{area} >= $minArea;
            }
        }
        else
        {
            # As window and display rectangle do not overlap,
            # the display rectangle is not affected by the window.
            push @newRectangles, $rect;
        }
    }

    return @newRectangles;
}

sub createRectangle
{
    my ($x_min, $x_max, $y_min, $y_max) = @_;

    return {x_min => $x_min,
            x_max => $x_max,
            y_min => $y_min,
            y_max => $y_max,
            area  => ($x_max - $x_min) * ($y_max - $y_min)};
}

sub doRectanglesOverlap
{
    my ($r1, $r2) = @_;

    return not ($r1->{x_max} < $r2->{x_min}
                or $r1->{x_min} > $r2->{x_max}
                or $r1->{y_max} < $r2->{y_min}
                or $r1->{y_min} > $r2->{y_max});
}

__END__

=head1 NAME

FvwmSmartMaximize - The smart maximize module

=head1 SYNOPSIS

Module FvwmSmartMaximize [All|IgnoreMaxWindows]

FvwmSmartMaximize can only be invoked by fvwm. Command line invocation of the FvwmSmartMaximize module will not work.

=head1 DESCRIPTION

This module moves and resizes a current window to the largest free area of desktop/page
If no place found nothing happens.

=head1 INVOCATION

To be written

=head1 AUTHORS

Andreas Hoenen <andreas@hoenen-terstappen.de> and Thomas Funk <t.funk@web.de>.

=head1 SEE ALSO

For more information, see L<fvwm>, L<FVWM::Module>.

=cut

